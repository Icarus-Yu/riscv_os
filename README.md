# My RISC-V OS Project

## RISC-V OS - 实验三：页表与内存管理

这是一个从零开始构建的、逐步完善的 RISC-V 操作系统内核。本项目在前序实验基础上，进入了现代操作系统的核心领域：虚拟内存管理。

本项目目前已完成：
1.  **实验一：最小化内核启动** - 搭建了一个能在 QEMU 模拟器上成功引导，并向串口输出信息的最小化系统。
2.  **实验二：内核 `printf` 与清屏** - 实现了功能丰富的内核格式化输出函数 `printf` 和清屏功能，为后续开发提供了强大的调试工具。
3.  **实验三：页表与内存管理** - 构建了操作系统的基石：物理内存分配器和基于RISC-V Sv39规范的三级页表虚拟内存系统。

## 功能实现

本项目在原有基础上，新增了完整的内存管理模块：

-   **汇编入口 (`entry.S`)**: 设置初始的栈指针，为 C 语言环境做准备，并清零 `.bss` 段。
-   **链接脚本 (`kernel.ld`)**: 定义了内核代码在内存中的布局，设定了 `0x80000000` 作为内核的起始地址，与 xv6 保持一致。
-   **串口 (UART) 驱动 (`uart.c`)**: 一个简单的轮询式 UART 驱动，作为所有底层字符输出的基础。
-   **格式化输出 (`printf.c`)**: 实现了一个支持 `%d`, `%x`, `%p`, `%s`, `%c` 等常用格式的 `printf` 函数。
-   **物理内存分配器 (`kalloc.c`)**:
    * 实现了一个页大小为4KB的物理内存分配器。
    * 通过空闲链表的方式管理所有可用物理内存。
    * 提供了 `kalloc()` 和 `kfree()` 接口用于分配和释放物理页。
-   **页表与虚拟内存管理 (`vm.c`)**:
    * 基于 RISC-V Sv39 三级页表架构实现。
    * 实现了 `walk` 和 `mappages` 等核心函数，用于创建和管理页表映射。
    * 完成了内核自身的虚拟地址空间创建，将内核代码、数据以及设备内存映射到虚拟地址空间。
    * 通过对`satp`寄存器的设置，最终激活了分页机制，使内核运行在虚拟内存之上。
-   **模块化代码结构**: 项目包含 `include` 目录用于存放头文件，使接口与实现分离，代码结构更清晰、更规范。

## 环境要求

在开始之前，请确保您已经安装了 RISC-V 交叉编译工具链和 QEMU 模拟器。

-   **交叉编译工具链**: `riscv64-unknown-elf-gcc`, `riscv64-unknown-elf-ld`, 等。
-   **模拟器**: `qemu-system-riscv64`

## 如何构建和运行

本项目使用 `Makefile` 进行自动化管理。

#### 编译内核

在项目根目录下，执行以下命令来编译所有源代码并链接生成内核文件 `kernel.elf`。

```bash
make
```
文件结构说明
```
.
├── include/
│   └── console.h      # 项目共享的头文件，定义函数原型
├── kernel/
│   ├── entry.S        # 汇编入口与早期初始化
│   ├── kernel.ld      # 链接器脚本，定义内存布局
│   ├── main.c         # C代码主函数
│   ├── printf.c       # printf 和清屏功能的实现
│   ├── uart.c         # 串口驱动程序
│   ├── kalloc.c       # 物理内存分配器 <--- 新增
│   └── vm.c           # 页表及虚拟内存管理 <--- 新增
├── .vscode/
│   └── c_cpp_properties.json # VS Code 编辑器配置文件 (可选)
├── Makefile         # 自动化构建脚本
└── README.md        # 本说明文件
```
