# **系统设计**
## 架构设计说明
本次实验实现了一个最简化的 RISC-V 操作系统内核。其核心启动流程如下：

1. 引导加载：CPU 从 _start 符号开始执行（在 kernel.ld 中定义）。

2. 汇编初始化 (entry.S)：

   * 设置栈指针 sp，为 C 函数调用准备好栈空间。

    - 清零 .bss 段，确保所有未初始化的全局变量和静态变量都被初始化为0。这是通过直接在汇编代码中循环写入零实现的。

    - 跳转到 C 语言的 main 函数，将控制权交给 C 代码。

1. C 主函数 (main.c)：

    - 调用 uart_puts 函数，通过串口输出 "Hello 05\n" 字符串。

4. 串口驱动 (uart.c)：

    - 提供 uart_putc 和 uart_puts 函数，通过向 QEMU virt 虚拟机的 UART 设备内存映射地址（基地址为 0x10000000L）写入数据，从而实现字符和字符串的发送。

5. 系统停机：main 函数执行完毕后，程序进入一个死循环 (while(1);)，并通过 wfi 指令使 CPU 休眠，等待中断，防止其意外退出或失控。
## 关键数据结构
本次实验的内核非常简单，没有复杂的数据结构。核心的数据区域和内存布局由链接脚本 kernel.ld 定义：

- 栈 (Stack)：在 entry.S 的 .bss 段中，为启动栈预留了 4096 字节的空间。栈指针 sp 在启动时被初始化为该区域的顶部地址 stack_top。

- 内存段 (Memory Segments)：kernel.ld 将内核的各个段（.text, .rodata, .data, .bss）从基地址 0x80000000 开始线性排布。同时，定义了 etext, bss_start, bss_end, end 等符号，供代码（如 entry.S 中的 BSS 清零操作）使用。
## 与xv6的对比分析
本次实验在设计上多处参考了 xv6 操作系统，但进行了一定的简化和修改：

- 入口点与栈设置：与 xv6 类似，内核的第一条指令就是设置栈指针 sp，为后续的函数调用做准备。

- 内核基地址：同样参考了 xv6，将内核的链接基地址设置为 0x80000000。

- BSS 段清零：xv6 中通过调用一个 C 函数来完成 BSS 段的清零。在本次实验中，为了简化初期阶段的 C 环境依赖，该过程被直接在 entry.S 中通过汇编代码实现。
## 设计决策理由
- 汇编清零 BSS：在操作系统启动的极早期，C 环境（尤其是栈）刚刚建立，此时依赖 C 函数可能引入不必要的复杂性。直接使用汇编代码操作 bss_start 和 bss_end 两个地址来清零 BSS 段，逻辑清晰，执行高效，且不依赖于完整的 C 运行时环境。

- 轮询式串口驱动：采用轮询（Polling）方式检查串口的线路状态寄存器（LSR）来判断是否可以发送数据。这种方式实现简单，在内核初始化这种单线程、无中断的场景下是完全够用的。虽然效率不高，但避免了引入复杂的中断处理机制。

- Makefile 自动化构建：使用 Makefile 将编译、链接和启动 QEMU 的过程自动化，可以极大地提高开发和测试效率。通过定义规则，可以清晰地管理源文件、目标文件和依赖关系
---
# **实验过程部分**
## 实验步骤记录
实现启动汇编 (entry.S)：编写 _start 函数，完成栈指针设置、BSS 段清零和对 main 函数的跳转。

编写链接脚本 (kernel.ld)：定义程序的入口点为 _start，设置内核基地址为 0x80000000，并依次排列 .text, .rodata, .data, .bss 等段，同时导出关键地址符号。

实现串口驱动 (uart.c)：根据 QEMU virt 机器的 UART 硬件规格，定义相关寄存器的地址，并实现 uart_putc 和 uart_puts 函数用于字符和字符串输出。

完成 C 主函数 (main.c)：编写 main 函数，调用 uart_puts 打印目标字符串，并在任务完成后进入死循环。

编写 Makefile：创建 Makefile 文件，定义 riscv64-unknown-elf- 工具链，设置编译和链接参数，并添加 all, clean, qemu, qemu-gdb 等常用目标。

编译与运行：在终端中执行 make qemu 命令，编译所有源文件，链接生成 kernel.elf 可执行文件，并启动 QEMU 加载运行该内核。

验证结果：观察 QEMU 的输出窗口，确认 "Hello 05" 字符串是否被正确打印。


## 问题与解决方案
注意.S文件的后缀中的s是大写，Makefile可能无法进行
---
# **源码总结理解**
entry.S：作为内核的入口，是 CPU 加电后执行的第一段代码。它的核心使命是建立一个基本的执行环境（主要是栈），并清空 BSS 段，为即将到来的 C 代码扫清障碍，最后将控制权安全地转交给 main 函数。

kernel.ld：是内核的内存蓝图。它告诉链接器如何组织编译后的各个代码和数据段，将它们放置在哪个内存地址，并创建了几个关键的符号（如 bss_start），这些符号成为汇编代码和 C 代码之间沟通内存布局的桥梁。

uart.c：是一个简单的硬件驱动程序。它通过直接读写特定物理内存地址（0x10000000L）的方式，与 QEMU 模拟的 UART 硬件进行交互，实现了向外部世界（控制台）发送信息的功能。

main.c：是 C 代码的逻辑起点。在这个实验中，它的功能很简单，就是调用底层驱动（uart.c）来验证整个系统的启动流程是否成功。它标志着系统从底层汇编初始化阶段正式进入了高级语言应用阶段。

Makefile：是整个项目的“项目管理器”。它定义了一套完整的自动化规则，将复杂的编译、链接过程简化为一条命令（如 make），并提供了便捷的调试和运行指令（如 make qemu），是保证项目工程化和提高开发效率的关键。

---
# **测试验证部分**
## 功能测试结果
执行 make qemu 命令后，QEMU 正常启动，并在终端（标准输出）中打印出以下内容：
```zsh
Hello 05
```
## 性能数据
本次实验为一个功能验证性的内核，未进行性能测试，性能也不是本次实验的关注点。
## 异常测试
未进行专门的异常测试。当前代码没有实现任何中断或异常处理机制。在 main 函数执行完毕后，通过 while(1); 和 wfi 指令让系统进入停机状态，以防止 CPU 执行未知指令导致不可预测的行为
## 运行截图/录屏

---
